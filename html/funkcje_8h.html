<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALOPS - Filip Kudła: Dokumentacja pliku alops/funkcje.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="obwodzik.PNG"/></td>
  <td id="projectalign">
   <div id="projectname">ALOPS - Filip Kudła<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Analiza Liniowych Obwodów Prądu Stałego</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Wygenerowano przez Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Szukaj');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Wczytywanie...</div>
<div class="SRStatus" id="Searching">Szukanie...</div>
<div class="SRStatus" id="NoMatches">Brak dopasowań</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fe72c110f2ac5d8e831ca00b394f6e2a.html">alops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Definicje</a> &#124;
<a href="#func-members">Funkcje</a>  </div>
  <div class="headertitle"><div class="title">Dokumentacja pliku funkcje.h</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &quot;<a class="el" href="struktury_8h_source.html">struktury.h</a>&quot;</code><br />
</div>
<p><a href="funkcje_8h_source.html">Idź do kodu źródłowego tego pliku.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Definicje</h2></td></tr>
<tr class="memitem:a94fd855811ccb4397ae9fbdc621478e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a94fd855811ccb4397ae9fbdc621478e1">FUNKCJE_H</a></td></tr>
<tr class="separator:a94fd855811ccb4397ae9fbdc621478e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funkcje</h2></td></tr>
<tr class="memitem:a572eb1ed453f9bf68fd73372cf50a185"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a572eb1ed453f9bf68fd73372cf50a185">main</a> (int liczba_param, char *param[])</td></tr>
<tr class="memdesc:a572eb1ed453f9bf68fd73372cf50a185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja glowna programu.  <br /></td></tr>
<tr class="separator:a572eb1ed453f9bf68fd73372cf50a185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5906a58e415695ad54b73b6bc8f62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a85a5906a58e415695ad54b73b6bc8f62">odczyt_wejscia</a> (const std::string &amp;nazwa_pliku)</td></tr>
<tr class="memdesc:a85a5906a58e415695ad54b73b6bc8f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja odczytuje elementy z pliku tekstowego.  <br /></td></tr>
<tr class="separator:a85a5906a58e415695ad54b73b6bc8f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e571b269f78519ae8c9f1e490455cb"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a55e571b269f78519ae8c9f1e490455cb">wektor_wezlow</a> (const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy)</td></tr>
<tr class="memdesc:a55e571b269f78519ae8c9f1e490455cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja tworzy kontener unikalnych wezlow z obwodu.  <br /></td></tr>
<tr class="separator:a55e571b269f78519ae8c9f1e490455cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9a47948b4437490d988d2205d9ad07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a1b9a47948b4437490d988d2205d9ad07">dodaj_rez_obok_sem</a> (std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy, const std::set&lt; int &gt; &amp;wezly)</td></tr>
<tr class="memdesc:a1b9a47948b4437490d988d2205d9ad07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja dodaje niwelujace sie rezystory na galaz z SEM.  <br /></td></tr>
<tr class="separator:a1b9a47948b4437490d988d2205d9ad07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208fa22ac183f4c456d581b60850106b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="struktury_8h.html#a0d6c203a1407d94232f467e661486a66">macierz</a>, std::unordered_map&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a208fa22ac183f4c456d581b60850106b">coltri</a> (const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy, const std::set&lt; int &gt; &amp;wezly)</td></tr>
<tr class="memdesc:a208fa22ac183f4c456d581b60850106b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja tworzy macierz (uklad rownan) za pomoca metody Coltriego.  <br /></td></tr>
<tr class="separator:a208fa22ac183f4c456d581b60850106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db710bc9195d74b9e9d6e8d7a3f07f1"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a2db710bc9195d74b9e9d6e8d7a3f07f1">gauss</a> (const std::pair&lt; <a class="el" href="struktury_8h.html#a0d6c203a1407d94232f467e661486a66">macierz</a>, std::unordered_map&lt; int, int &gt; &gt; &amp;uklad_rownan_i_mapa, const std::set&lt; int &gt; &amp;wezly)</td></tr>
<tr class="memdesc:a2db710bc9195d74b9e9d6e8d7a3f07f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja oblicza macierz za pomoca metody eliminacji Gaussa-Jordana-Crouta.  <br /></td></tr>
<tr class="separator:a2db710bc9195d74b9e9d6e8d7a3f07f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c017c7286dd0c25477016d14e5687a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a9c017c7286dd0c25477016d14e5687a2">licz_prady</a> (std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy, std::unordered_map&lt; int, double &gt; &amp;potencjaly)</td></tr>
<tr class="memdesc:a9c017c7286dd0c25477016d14e5687a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja oblicza prad na kazdym elemencie.  <br /></td></tr>
<tr class="separator:a9c017c7286dd0c25477016d14e5687a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98be3d5384aa9042f826db3e9664c15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#aa98be3d5384aa9042f826db3e9664c15">licz_napiecia</a> (std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy, std::unordered_map&lt; int, double &gt; &amp;potencjaly)</td></tr>
<tr class="memdesc:aa98be3d5384aa9042f826db3e9664c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja oblicza odlozone napiecie na kazdym elemencie.  <br /></td></tr>
<tr class="separator:aa98be3d5384aa9042f826db3e9664c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2787250bcdf1b3c3301b71c9cd0dda9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#ab2787250bcdf1b3c3301b71c9cd0dda9">licz_moce</a> (std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy)</td></tr>
<tr class="memdesc:ab2787250bcdf1b3c3301b71c9cd0dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja oblicza moc wydzielona na kazdym elemencie i bilans obwodu.  <br /></td></tr>
<tr class="separator:ab2787250bcdf1b3c3301b71c9cd0dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922ea960fd7fa7ee1aa413d6e5fdb8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funkcje_8h.html#a922ea960fd7fa7ee1aa413d6e5fdb8a7">zapis_wyjscia</a> (const std::string &amp;nazwa_pliku, const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;elementy)</td></tr>
<tr class="memdesc:a922ea960fd7fa7ee1aa413d6e5fdb8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funkcja wypisuje wszystkie elementy obwodu, ich parametry i bilans obwodu.  <br /></td></tr>
<tr class="separator:a922ea960fd7fa7ee1aa413d6e5fdb8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Dokumentacja definicji</h2>
<a id="a94fd855811ccb4397ae9fbdc621478e1" name="a94fd855811ccb4397ae9fbdc621478e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fd855811ccb4397ae9fbdc621478e1">&#9670;&#160;</a></span>FUNKCJE_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNKCJE_H</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Dokumentacja funkcji</h2>
<a id="a208fa22ac183f4c456d581b60850106b" name="a208fa22ac183f4c456d581b60850106b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208fa22ac183f4c456d581b60850106b">&#9670;&#160;</a></span>coltri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="struktury_8h.html#a0d6c203a1407d94232f467e661486a66">macierz</a>, std::unordered_map&lt; int, int &gt; &gt; coltri </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>wezly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja tworzy macierz (uklad rownan) za pomoca metody Coltriego. </p>
<p>Funkcja wprowadza do macierzy wspolczynniki kazdego potencjalu uzywajac metody potencjalow wezlowych. Napotkane galezie ze zrodlem elektromotorycznym traktuje jako galezie z opornoscia 1 om. Funkcja tworzy takze mape wezlow na podstawie kontenera tworzonego w <a class="el" href="funkcje_8h.html#a55e571b269f78519ae8c9f1e490455cb" title="Funkcja tworzy kontener unikalnych wezlow z obwodu.">wektor_wezlow()</a>, tak aby zaczynaly sie od 0 do n. </p><dl class="section return"><dt>Zwraca</dt><dd>std::pair&lt;macierz, std::unordered_map&lt;int, int&gt;&gt; Para macierzy (wektora wektorow) i mapy stare2nowe </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wezly</td><td>Kontener wezlow z obwodu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b9a47948b4437490d988d2205d9ad07" name="a1b9a47948b4437490d988d2205d9ad07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9a47948b4437490d988d2205d9ad07">&#9670;&#160;</a></span>dodaj_rez_obok_sem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; dodaj_rez_obok_sem </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>wezly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja dodaje niwelujace sie rezystory na galaz z SEM. </p>
<p>Funkcja dodaje rezystor o wartosci -1 obok galezi ze zrodlem elektromotorycznym, aby pozniej traktowac galaz z SEM jako galaz z opornoscia 1 om. </p><dl class="section return"><dt>Zwraca</dt><dd>std::vector&lt;element&gt; Wektor elementow z nowymi ujemnymi rezystorami </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2db710bc9195d74b9e9d6e8d7a3f07f1" name="a2db710bc9195d74b9e9d6e8d7a3f07f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db710bc9195d74b9e9d6e8d7a3f07f1">&#9670;&#160;</a></span>gauss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; int, double &gt; gauss </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="struktury_8h.html#a0d6c203a1407d94232f467e661486a66">macierz</a>, std::unordered_map&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uklad_rownan_i_mapa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>wezly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja oblicza macierz za pomoca metody eliminacji Gaussa-Jordana-Crouta. </p>
<p>Funkcja sprowadza macierz do postaci trojkatnej (uzyskuje zero nad i pod przekatna macierzy). Zamienia wiersze (rownanie) z innym wierszem, w ktorym wystepuje wiekszy wspolczynnik w kolumnie. Metoda ta sprowadza macierz rozszerzona ukladu rownan do postaci bazowej (macierzy jednostkowej). Z tej postaci mozna wprost odczytac potencjaly w wezlach. </p><dl class="section return"><dt>Zwraca</dt><dd>std::unordered_map&lt;int, double&gt; Mapa potencjalow w wezlach </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uklad_rownan_i_mapa</td><td>Para macierzy i mapy stare2nowe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wezly</td><td>Kontenera wezlow obwodu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2787250bcdf1b3c3301b71c9cd0dda9" name="ab2787250bcdf1b3c3301b71c9cd0dda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2787250bcdf1b3c3301b71c9cd0dda9">&#9670;&#160;</a></span>licz_moce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void licz_moce </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja oblicza moc wydzielona na kazdym elemencie i bilans obwodu. </p>
<p>Wykorzystuje do tego obliczone wczesniej prad i napiecie na kazdym elemencie obwodu. Jesli moc jest dodatnia, to znaczy, ze element pobiera energie. Jesli ujemna, to znaczy, ze ja oddaje. Funkcja oblicza bilans mocy na podstawie mocy oddanej lub pobranej dla kazdego elementu. </p><dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Zwraca</td><td>wektor elementow uzupelniony o moc dla kazdego elementu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa98be3d5384aa9042f826db3e9664c15" name="aa98be3d5384aa9042f826db3e9664c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98be3d5384aa9042f826db3e9664c15">&#9670;&#160;</a></span>licz_napiecia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void licz_napiecia </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>potencjaly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja oblicza odlozone napiecie na kazdym elemencie. </p>
<p>Wykorzystuje do tego obliczony wczesniej prad (dla rezystora) lub mape potencjalow wezlowych dla zrodel. </p><dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">potencjaly</td><td>Mapa potencjalow wezlowych </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Zwraca</td><td>wektor elementow uzupelniony o odlozone dla kazdego elementu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c017c7286dd0c25477016d14e5687a2" name="a9c017c7286dd0c25477016d14e5687a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c017c7286dd0c25477016d14e5687a2">&#9670;&#160;</a></span>licz_prady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void licz_prady </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>potencjaly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja oblicza prad na kazdym elemencie. </p>
<p>Wykorzystuje do tego obliczone wczesniej potencjaly w kazdym wezle obwodu. Jesli prad jest dodatni, to plynie od wezla poczatkowego do koncowego elementu. Jesli ujemny, to na odwrot. </p><dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">potencjaly</td><td>Mapa potencjalow wezlowych </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Zwraca</td><td>wektor elementow uzupelniony o prad dla kazdego elementu </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a572eb1ed453f9bf68fd73372cf50a185" name="a572eb1ed453f9bf68fd73372cf50a185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572eb1ed453f9bf68fd73372cf50a185">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>liczba_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>param</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja glowna programu. </p>
<dl class="section return"><dt>Zwraca</dt><dd>int </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">liczba_param</td><td>Liczba parametrow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param[]</td><td>Tablica parametrow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85a5906a58e415695ad54b73b6bc8f62" name="a85a5906a58e415695ad54b73b6bc8f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a5906a58e415695ad54b73b6bc8f62">&#9670;&#160;</a></span>odczyt_wejscia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; odczyt_wejscia </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nazwa_pliku</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja odczytuje elementy z pliku tekstowego. </p>
<p>na podstawie wprowadzonych danych w formacie &lt;typ&gt;,&lt;wezel poczatkowy&gt;,&lt;wezel koncowy&gt;,&lt;wartosc&gt;. </p><dl class="section return"><dt>Zwraca</dt><dd>std::vector&lt;element&gt; Wektor elementow </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nazwa_pliku</td><td>Nazwa pliku wejsciowego </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55e571b269f78519ae8c9f1e490455cb" name="a55e571b269f78519ae8c9f1e490455cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e571b269f78519ae8c9f1e490455cb">&#9670;&#160;</a></span>wektor_wezlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int &gt; wektor_wezlow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja tworzy kontener unikalnych wezlow z obwodu. </p>
<p>wpisujac kazdy wezel elementu w sposob posortowany od najmniejszych do najwiekszych wartosci. </p><dl class="section return"><dt>Zwraca</dt><dd>std::set&lt;int&gt; Kontener wezlow obwodu </dd></dl>
<dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a922ea960fd7fa7ee1aa413d6e5fdb8a7" name="a922ea960fd7fa7ee1aa413d6e5fdb8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922ea960fd7fa7ee1aa413d6e5fdb8a7">&#9670;&#160;</a></span>zapis_wyjscia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zapis_wyjscia </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nazwa_pliku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structelement.html">element</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funkcja wypisuje wszystkie elementy obwodu, ich parametry i bilans obwodu. </p>
<p>Funkcja wypisuje do pliku wyjscia charakterystyke kazdego elementu. Funkcja oblicza bilans mocy na podstawie mocy oddanej lub pobranej dla kazdego elementu. </p><dl class="params"><dt>Parametry</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nazwa_pliku</td><td>Nazwa pliku wyjsciowego </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementy</td><td>Wektor elementow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Wygenerowano przez&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
